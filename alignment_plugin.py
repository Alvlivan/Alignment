# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AlignmentPlugin
                                 A QGIS plugin
 Alignment datas ...
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-04
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Alexander Ivanov
        email                : alvlivan@mail.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import * #QSettings, QTranslator, QCoreApplication, Qt, QVariant, QDate, QTime, QDateTime
from qgis.PyQt.QtGui import * #QIcon, QStandardItemModel, QStandardItem
from qgis.PyQt.QtWidgets import * #QAction
from qgis.core import * #QgsProject, QgsGeometry, QgsField, Qgis, QgsAbstractGeometry, QgsPointXY, QgsFeature, QgsRectangle, QgsFeatureRequest
# Initialize Qt resources from file resources.py
from .resources import *

# Import the code for the DockWidget
from .alignment_plugin_dockwidget import AlignmentPluginDockWidget
from .alignment_plugin_dialog_project import AlignmentDialogProjectWidget
from .alignment_plugin_dialog_modification import AlignmentDialogModificationWidget
import os.path
import math
import random


class AlignmentPlugin:
    """QGIS Plugin Implementation."""
    
    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'AlignmentPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Alignment')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'AlignmentPlugin')
        self.toolbar.setObjectName(u'AlignmentPlugin')

        #print("** INITIALIZING AlignmentPlugin")

        self.pluginIsActive = False
        #self.dockwidget = AlignmentPluginDockWidget()
        self.dockwidget = AlignmentPluginDockWidget()
        self.dialogproject = AlignmentDialogProjectWidget()
        self.dialogmodification = AlignmentDialogModificationWidget()
        
        self.dialogproject.pbOk.clicked.connect(self.ProjectInData)
        self.dialogproject.pbCancel.clicked.connect(self.dialogproject.close)
        
        self.dialogmodification.pbOk.clicked.connect(self.ModificationFeatures)
        self.dialogmodification.pbCancel.clicked.connect(self.dialogmodification.close)

        # ContextMenuPolicy должен быть установлен в Qt.CustomContextMenu
        # В противном случае сигнал customContextMenuRequested не может быть использован
        self.dockwidget.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.dockwidget.customContextMenuRequested.connect(self.ContextMenu)
               
    def ContextMenu(self):#не работает как надо
        #print(self)
        self.contextMenu = QMenu()
        self.actionFindDuplicates = self.contextMenu.addAction("Find duplicates")
        self.actionFindDuplicates.triggered.connect(self.FindDuplicates)
        self.actionOffsetAzimuth = self.contextMenu.addAction("RUMB, OFFSET, AZIMUTH")
        self.actionOffsetAzimuth.triggered.connect(self.dialogproject.show)
        self.actionModificationFeatures = self.contextMenu.addAction("Modification features")
        self.actionModificationFeatures.triggered.connect(self.dialogmodification.show)
        self.contextMenu.exec(QCursor.pos())
        #self.contextMenu.show()
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('AlignmentPlugin', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag = True,
        add_to_menu = True,
        add_to_toolbar = True,
        status_tip = None,
        whats_this = None,
        parent = None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(':/plugins/alignment_plugin/icon.png')
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)
        return action

    def LoaderLayers(self):
        #print("loaderLayers()")
        # Fetch the currently model loaded layers
        #ids = ids or []
        self.root = QgsProject.instance().layerTreeRoot() #.clone()
        self.model = QgsLayerTreeModel(self.root) #QStandardItemModel()
        
#        for layer in self.root.findLayers():
#            layer.setVisible(Qt.Checked if layer.layerId() in ids else Qt.Unchecked)
#            self.item = QStandardItem(layer.name())
#            #item.setIcon(1, ':/plugins/alignment_plugin/icon.png') #добавить иконку к имени каждого слоя
#            self.model.appendRow(self.item)
#            #self.model.setFlags(...)
            
        #print(model)
            
        # Clear the contents of the comboBox from previous runs
        #self.dockwidget.comboBox.clear()
            
        # Populate dockwidget with names of all the loaded layers
        self.dockwidget.lvExceed.setModel(self.model)
        self.dockwidget.cbTotalData.setModel(self.model)
        self.dockwidget.lvOffset.setModel(self.model)
        self.dockwidget.lvBasis.setModel(self.model)
        self.dockwidget.cbJustusData.setModel(self.model)
        self.dockwidget.cbExceedAll.setModel(self.model)
        self.dockwidget.cbOffsetAll.setModel(self.model)
        self.dockwidget.cbBasisAll.setModel(self.model)
        self.dockwidget.cbTotalDataAll.setModel(self.model)
        self.dockwidget.cbJustusDataAll.setModel(self.model)
        self.dialogproject.lwProject.setModel(self.model)
    
    #получить векторный слой из имени
    def VectorLayerFromName(self, name):
        Layers = QgsProject.instance().layerTreeRoot().children()
        for layer in Layers:
            if  (layer.name() == name):
                lyr = layer
                return lyr.layer()
            
    def ClearLayer(self):
        layer = ""
        if  (self.dockwidget.sender() == self.dockwidget.pbTotalDataClear):
            layer = self.dockwidget.cbTotalData.currentText()
        if  (self.dockwidget.sender() == self.dockwidget.pbJustusDataClear):
            layer = self.dockwidget.cbJustusData.currentText()
        if  (self.dockwidget.sender() == self.dockwidget.pbTotalDataAllClear):
            layer = self.dockwidget.cbTotalDataAll.currentText()
        if  (self.dockwidget.sender() == self.dockwidget.pbJustusDataAllClear):
            layer = self.dockwidget.cbJustusDataAll.currentText()
            
        mLayer = self.VectorLayerFromName(layer)
        
        #удалить все данные из слоя
        mLayer.startEditing()
        mLayer.beginEditCommand("begin")
        for feature in mLayer.getFeatures():
            mLayer.deleteFeature(feature.id())
        mLayer.endEditCommand()
        mLayer.commitChanges()
        
    def ModificationFeatures(self):
        #print("modificationFeatures()")
        minMod = self.dialogmodification.dsbminmod.value() #считать с ui
        maxMod = self.dialogmodification.dsbmaxmod.value() #считать с ui
        #print(minMod, maxMod)
        
        self.dialogmodification.close()
            
        dLayer = self.dockwidget.lvOffset.currentIndex().data()
        mDataLayer = self.VectorLayerFromName(dLayer)

        if  ((mDataLayer.geometryType()) != QgsWkbTypes.PointGeometry):
            print("((mDataLayer.geometryType()) != QgsWkbTypes.PointGeometry)")
            #...сделать...mQGisIface->messageBar()->pushMessage( mProjectLayer->name() + tr(" - not correct layer (ERROR: ProjectInOffset())"), tr("(ERROR: )") );
            return
        
        #self.dockwidget.tInfoExceed.clear()
        self.dockwidget.tInfoOffset.clear()
        #self.dockwidget.tInfoBasis.clear()
        
        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        
        #вывод в statusBarIface()
        self.iface.statusBarIface().showMessage("Modification: " + dLayer)
        
        self.dockwidget.tInfoOffset.append( "Data: " + dLayer)
        self.dockwidget.tInfoOffset.append( "Modification: " + "from: " + str(minMod) + " to: " + str(maxMod))
        
        #проверить наличие полей (PROF, PK) в слое
        DataCheckingFields = self.CheckingFields(mDataLayer, ["X", "Y"])
        
        if (DataCheckingFields == False):
            print ("#return прервать функцию", "(DataCheckingFields == False)")
            return

        #удалить и создать поля (OFFSET, AZIMUTH)
        listFields = ["XMOD", "YMOD"]
        #создать поля в Data
        self.CreatingFields(mDataLayer, listFields)
        
        fieldDataProf = mDataLayer.fields().field("PROF")
        fieldDataPk = mDataLayer.fields().field("PK")
        fieldDataX = mDataLayer.fields().field("X")
        fieldDataY = mDataLayer.fields().field("Y")
        fieldDataXmod = mDataLayer.fields().field("XMOD")
        fieldDataYmod = mDataLayer.fields().field("YMOD")
#            fieldDataRumb = mDataLayer.fields().field("RUMB")
#            fieldDataOffset = mDataLayer.fields().field("OFFSET")
#            fieldDataAzimuth = mDataLayer.fields().field("AZIMUTH")
        
        mapDataFeatures = self.MapLayerFeatures(mDataLayer)
        
        mDataLayer.startEditing()
        mDataLayer.beginEditCommand("begin")

        p = 0
        self.dockwidget.progress.setRange( 0, len(mapDataFeatures))
        self.dockwidget.progress.setFormat( "Modification features %p%" )
        fData = 0
        while ( fData < len(mapDataFeatures)):
            p += 1
            self.dockwidget.progress.setValue(p)

            valueDataProf = mapDataFeatures[fData].attribute(fieldDataProf.name())
            valueDataPk = mapDataFeatures[fData].attribute(fieldDataPk.name())
            valueDataX = mapDataFeatures[fData].attribute(fieldDataX.name())
            valueDataY = mapDataFeatures[fData].attribute(fieldDataY.name())
            valueDataXmod = mapDataFeatures[fData].attribute(fieldDataXmod.name())
            valueDataYmod = mapDataFeatures[fData].attribute(fieldDataYmod.name())

            #//модифицируем координаты
            azimuth = round((random.uniform(0, 360)), 3)
            distance = round((random.uniform(minMod, maxMod)), 3)
            rad = round((azimuth * math.pi / 180), 3)
            
            valueXmod = valueDataX + ((math.sin(rad)) * distance)
            valueYmod = valueDataY + ((math.cos(rad)) * distance)

#            print("X =", valueDataX, "Y =", valueDataY)
#            print("azimuth =", azimuth, "distance =", distance, "rad =", rad)
#            print("XMOD =", valueXmod, "YMOD =", valueYmod)

            mDataLayer.changeAttributeValue(mapDataFeatures[fData].id(), mDataLayer.fields().indexFromName(fieldDataXmod.name()), valueXmod, valueDataXmod)
            mDataLayer.changeAttributeValue(mapDataFeatures[fData].id(), mDataLayer.fields().indexFromName(fieldDataYmod.name()), valueYmod, valueDataYmod)
            
            fData += 1
    
        mDataLayer.endEditCommand()
        mDataLayer.commitChanges()

        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        self.dockwidget.progress.setFormat("Modification features DONE")
          
        self.dockwidget.tabInfo.setTabEnabled(0,False)
        self.dockwidget.tabInfo.setTabEnabled(1,True)
        self.dockwidget.tabInfo.setTabEnabled(2,False)
        self.dockwidget.tabInfo.setCurrentIndex(1)
        self.dockwidget.toolMetod.setCurrentIndex(4)
        self.iface.statusBarIface().showMessage("DONE")
            
    #получить уникальные значения
    def UniqueValues(self, layer, field):
        uValues = []
#                p = 0
#                self.dockwidget.progress.setRange(0, layer.featureCount())
#                self.dockwidget.progress.setFormat("ListValues %p%")
        for feature in layer.getFeatures():
#                    p += 1
#                    self.dockwidget.progress.setValue(p)
            unique = feature.attribute(field.name())
            if  (unique in uValues) or (unique == None):
                continue
            else:
                uValues.append(unique)
        return uValues
    
    #получить список свойств
    def MapFeatures(self, layer, field, variant):
        mFeatures = []
        for feature in layer.getFeatures():
            valueField = feature.attribute(field.name())
            if  ( valueField == variant ) or ( valueField == None ):
                mFeatures.append(feature)
        return mFeatures
        
    #получить список свойств
    def MapLayerFeatures(self, layer):
        mFeatures = []
        for feature in layer.getFeatures():
            mFeatures.append(feature)
        return mFeatures
    
    #получить словарь свойств
    def DictLayerFeatures(self, layer):
        dFeatures = {}
        for feature in layer.getFeatures():
            valueProf = feature.attribute(layer.fields().field("PROF").name())
            valuePk = feature.attribute(layer.fields().field("PK").name())
            valueKey = valueProf + str(valuePk)
            dFeatures[valueKey] = feature
        #print(dFeatures)
        return dFeatures
    
    #проверить наличие полей(fields) в слое(layer)
    def CheckingFields(self, layer, fields): 
        layerFields = layer.fields()
        boolFields = True
        for fld in fields:
            #print(fld)
            if  layerFields.indexFromName(fld) < 0:
                self.iface.messageBar().pushMessage("Not found field ", fld)
                boolFields = False
        return boolFields
        
    #удалить поля(fields) в слое(layer)
    def DeletingFields(self, layer, fields):
        #print("DeletingFields")
        layerFields = layer.fields()
        delFields = []
        for fld in fields:
            #print(fld)
            if  (layerFields.indexFromName(fld) >= 0) and (layerFields.indexFromName(fld) < layerFields.count()):
                #print(layerFields.indexFromName(fld))
                delFields.append(layerFields.indexFromName(fld))
                
        layer.startEditing()
        layer.beginEditCommand("begin")
        layer.deleteAttributes(delFields)
        layer.endEditCommand()
        layer.commitChanges()

    #создать поля(fields) в слое(layer)
    def CreatingFields(self, layer, fields):
        #print("CreatingFields")
        layer.startEditing()
        layer.beginEditCommand("begin")  
        for fld in fields:
            addField = QgsField()
            addField.setName(fld)
            if  (layer.fields().exists(layer.fields().indexFromName(fld))):
                continue
            if  ((fld == "V") or (fld == "AUTHOR") or (fld == "PROF") or (fld == "BEGIN") or (fld == "END") or (fld == "RUMB")):
                addField.setType(QVariant.String)
                addField.setLength(100) #проверить
            if  ((fld == "OFFSET") or (fld == "AZIMUTH") or (fld == "XMOD") or (fld == "YMOD") or 
                (fld == "H") or (fld == "HZ")or (fld == "Z")or (fld == "FH") or (fld == "ZF")or (fld == "ZFZ")):
                addField.setType(QVariant.Double)
                addField.setLength(20)
                addField.setPrecision(3)
            if  (fld == "DATE"): #проверить
                addField.setType(QVariant.Date)
            layer.dataProvider().addAttributes([addField])
            layer.updateFields()
        layer.endEditCommand()
        layer.commitChanges()
            
    def FindDuplicates(self):
        #print("FindDuplicates()")
        self.dockwidget.tInfoOffset.clear()
        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        
        layer = self.dockwidget.lvOffset.currentIndex().data()
        mDuplicateLayer = self.VectorLayerFromName(layer)
        
        #вывод в statusBarIface()
        s = chr(60)
        self.iface.statusBarIface().showMessage("Find duplicates in: " + layer)
        
        self.dockwidget.tInfoOffset.append( "Duplicate: " + layer)

        if (mDuplicateLayer == None): #переделать
          self.dockwidget.tInfoOffset.append( layer + " - not correct layer!" )
          #...инструкции
        
        #проверить наличие полей (PROF, PK) в слое
        DuplicateCheckingFields = self.CheckingFields(mDuplicateLayer, ["PROF", "PK"])
        
        if (DuplicateCheckingFields == False):
            print ("#return прервать функцию", "(DuplicateCheckingFields == False)")
            return

        fieldProf = mDuplicateLayer.fields().field("PROF")
        fieldPk = mDuplicateLayer.fields().field("PK")

        #mapDuplicatesFeatures = self.MapLayerFeatures(mDuplicateLayer)
        
        dictDuplicateFeatures = {}
        
        for feature in mDuplicateLayer.getFeatures():
            valueProf = feature.attribute(mDuplicateLayer.fields().field("PROF").name())
            valuePk = feature.attribute(mDuplicateLayer.fields().field("PK").name())
            valueKey = valueProf + "\t" + str(valuePk)
            dictDuplicateFeatures[feature.id()] = valueKey
        
        Duplicatesss = [(i,j) for i, iD in dictDuplicateFeatures.items() for j, jD in dictDuplicateFeatures.items() if (iD == jD) and i != j ]
        
        #print(Duplicatesss)
        
        myList = []
        for f in Duplicatesss:
            #print(f)
            for q in f:
                #print(dictDuplicateFeatures[q])
                myList.append(dictDuplicateFeatures[q])
        
        #берем уникальные значения
        #mySet = set(myList)
        for s in set(myList):
            self.dockwidget.tInfoOffset.append(s + "\t(duplicates)")
            
        #print(mySet)
            
#        p = 0
#        self.dockwidget.progress.setRange(0, len(mapDuplicateFeatures))
#        self.dockwidget.progress.setFormat("Duplicates %p% ")
        
#        f = 0
#        while f < (len(mapDuplicateFeatures)):
#            p += 1 #percent = p / float(len(mDuplicateLayer.featureCount())) * 100
#            self.dockwidget.progress.setValue(p)
#            valueProf = mapDuplicateFeatures[f].attribute(fieldProf.name())
#            valuePk = mapDuplicateFeatures[f].attribute(fieldPk.name())
#            
#            #print("1:", len(mapDuplicateFeatures), valueProf, valuePk)
#            
#            lFeatures = []
#            lFeatures.append(mapDuplicateFeatures[f])
#            
#            d = f
#            while d < (len(mapDuplicateFeatures)):
#                d += 1
#                if (d < (len(mapDuplicateFeatures))):
#                    vProf = mapDuplicateFeatures[d].attribute(fieldProf.name())
#                    vPk = mapDuplicateFeatures[d].attribute(fieldPk.name())
#
#                    if  ((valueProf == vProf) and (valuePk == vPk)):
#                        lFeatures.append(mapDuplicateFeatures[d])
#                        #print("2:", len(mapDuplicateFeatures), valueProf, valuePk)
#
#            if  ((len(lFeatures) > 1) and (valueProf != None) and (valuePk != None)):
#                self.dockwidget.tInfoOffset.append(valueProf + "\t" + str(valuePk) + "\t(" + str(len(lFeatures)) + " points)")
#                #print("вывод")
#            
#            for i in lFeatures:
#                mapDuplicateFeatures.remove(i)
#                #print("del: ", i.attribute(fieldPk.name()))
#
#            f = 0
            
        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        self.dockwidget.tabInfo.setTabEnabled(0,False)
        self.dockwidget.tabInfo.setTabEnabled(1,True)
        self.dockwidget.tabInfo.setTabEnabled(2,False)
        self.dockwidget.tabInfo.setCurrentIndex(1)
        self.dockwidget.toolMetod.setCurrentIndex(4)
        self.iface.statusBarIface().showMessage("DONE")

    def ProjectInData(self):
            #print("self.dialogproject.OK()")
            #...QSettings
            
#            lProject = dProject.currentItemText()
#            PvAzimuth = dProject.dsbPvAzimuthValue()
#            PpAzimuth = dProject.dsbPpAzimuthValue()
#            PvInterval = dProject.dsbPvIntervalValue()
#            PpInterval = dProject.dsbPpIntervalValue()           
            
        self.dialogproject.close()
        
        dLayer = self.dockwidget.lvOffset.currentIndex().data()
        pLayer = self.dialogproject.lwProject.currentIndex().data()
        mDataLayer = self.VectorLayerFromName(dLayer)
        mProjectLayer = self.VectorLayerFromName(pLayer)

        if  ((mDataLayer.geometryType() or mProjectLayer.geometryType()) != QgsWkbTypes.PointGeometry):
            print("((mDataLayer.geometryType() or mProjectLayer.geometryType()) != QgsWkbTypes.PointGeometry)")
            #mQGisIface->messageBar()->pushMessage( mProjectLayer->name() + tr(" - not correct layer (ERROR: ProjectInOffset())"), tr("(ERROR: )") );
            return

          #lInfo->setText( lOffset + " <<< " + lProject ) #заменить
        
        self.dockwidget.tInfoExceed.clear()
        self.dockwidget.tInfoOffset.clear()
        self.dockwidget.tInfoBasis.clear()
        
        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        
        #вывод в statusBarIface()
        s = chr(60)
        self.iface.statusBarIface().showMessage(dLayer + " " + s + s + s + " " + pLayer)
        
        self.dockwidget.tInfoOffset.append( "Data: " + dLayer)
        self.dockwidget.tInfoOffset.append( "Project: " + pLayer)
        
        #проверить наличие полей (PROF, PK) в слое
        DataCheckingFields = self.CheckingFields(mDataLayer, ["PROF", "PK", "X", "Y"])
        ProjectCheckingFields = self.CheckingFields(mProjectLayer, ["PROF", "PK", "X", "Y"])
        
        if (DataCheckingFields == False) or (ProjectCheckingFields == False):
            print ("#return прервать функцию", "(DuplicateCheckingFields == False)")
            return

        #удалить и создать поля (OFFSET, AZIMUTH)
        listFields = ["RUMB", "OFFSET", "AZIMUTH"]
        #удалить поля в Data, если они есть
        self.DeletingFields(mDataLayer, listFields)
        #создать поля в Data
        self.CreatingFields(mDataLayer, listFields)
        
        fieldDataProf = mDataLayer.fields().field("PROF")
        fieldDataPk = mDataLayer.fields().field("PK")
        fieldDataX = mDataLayer.fields().field("X")
        fieldDataY = mDataLayer.fields().field("Y")
        fieldDataRumb = mDataLayer.fields().field("RUMB")
        fieldDataOffset = mDataLayer.fields().field("OFFSET")
        fieldDataAzimuth = mDataLayer.fields().field("AZIMUTH")
        
        fieldProjectProf = mProjectLayer.fields().field("PROF")
        fieldProjectPk = mProjectLayer.fields().field("PK")
        fieldProjectX = mProjectLayer.fields().field("X")
        fieldProjectY = mProjectLayer.fields().field("Y")

        #///*< запись OFFSET, AZIMUTH в Data >*///
#        mapDataFeatures = self.MapLayerFeatures(mDataLayer)
#        mapProjectFeatures = self.MapLayerFeatures(mProjectLayer)
        
        DictDataFeatures = self.DictLayerFeatures(mDataLayer)
        DictProjectFeatures = self.DictLayerFeatures(mProjectLayer)
        
        mDataLayer.startEditing()
        mDataLayer.beginEditCommand("begin")

        p = 0
        self.dockwidget.progress.setRange( 0, len(DictDataFeatures))
        self.dockwidget.progress.setFormat( "RUMB, OFFSET, AZIMUTH %p%" )
        fData = 0
        for key,fData in DictDataFeatures.items():
            p += 1
            self.dockwidget.progress.setValue(p)

            valueDataProf = fData.attribute(fieldDataProf.name())
            valueDataPk = fData.attribute(fieldDataPk.name())
            #//valueDataX = fData.attribute(fieldDataX.name())
            #//valueDataY = fData.attribute(fieldDataY.name())
            valueDataRumb = fData.attribute(fieldDataRumb.name())
            valueDataOffset = fData.attribute(fieldDataOffset.name())
            valueDataAzimuth = fData.attribute(fieldDataAzimuth.name())
            
            if  (key not in DictProjectFeatures):
                continue
            
            fProject = DictProjectFeatures[key]
            
            valueProjectProf = fProject.attribute(fieldProjectProf.name())
            valueProjectPk = fProject.attribute(fieldProjectPk.name())
            #//valueProjectX = fProject.attribute(fieldProjectX.name())
            #//valueProjectY = fProject.attribute(fieldProjectY.name())

            if ((valueProjectProf == valueDataProf) and (valueProjectPk == valueDataPk )):
                azimuthDataProject = fProject.geometry().asPoint().azimuth(fData.geometry().asPoint())
                distanceDataProject = math.sqrt((fProject.geometry().asPoint()).sqrDist( fData.geometry().asPoint()))
                
                #print(str(valueProjectProf), str(valueProjectPk), "azimuthDataProject = ", str(azimuthDataProject), "distanceDataProject = ", str(distanceDataProject))

                valueAzimuth = round(azimuthDataProject, 3)
                valueOffset = round(distanceDataProject, 3)
                valueRumb = ""

                if  (azimuthDataProject < 0):
                    valueAzimuth = 360 + azimuthDataProject

                if  ((( valueAzimuth >= 355 ) and ( valueAzimuth <= 360 )) or 
                    (( valueAzimuth >= 0 ) and ( valueAzimuth < 5 ))):
                    valueRumb = "north"

                if  (( valueAzimuth >= 5 ) and ( valueAzimuth < 85 )):
                    valueRumb = "north-east"

                if  (( valueAzimuth >= 85 ) and ( valueAzimuth < 95 )):
                    valueRumb = "east"

                if  (( valueAzimuth >= 95 ) and ( valueAzimuth < 175 )):
                    valueRumb = "south-east"

                if  (( valueAzimuth >= 175 ) and ( valueAzimuth < 185 )):
                    valueRumb = "south"

                if  (( valueAzimuth >= 185 ) and ( valueAzimuth < 265 )):
                    valueRumb = "south-west"

                if  (( valueAzimuth >= 265 ) and ( valueAzimuth < 275 )):
                    valueRumb = "west"

                if  (( valueAzimuth >= 275 ) and ( valueAzimuth < 355 )):
                    valueRumb = "north-west"

                self.dockwidget.tInfoOffset.append( str(valueDataProf) + "\t" + str(valueDataPk) + "\t" + str(valueRumb) + "\t" + str(round(valueOffset,3)) + "\t" + str(round(valueAzimuth,3)))

                #//записать значения полей NF SF AZ
                mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName(fieldDataRumb.name()), valueRumb, valueDataRumb)
                mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName(fieldDataOffset.name()), valueOffset, valueDataOffset)
                mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName(fieldDataAzimuth.name()), valueAzimuth, valueDataAzimuth)

#                    #//ProfPknewInOffset()  заполнить поля PROF_NEW и PK_NEW
#                    valueDataProfNew = mapDataFeatures[fData].attribute(fieldDataProfNew.name())
#                    valueDataPkNew = mapDataFeatures[fData].attribute(fieldDataPkNew.name())

#                    #//определить тип профиля и удалить буквы
#                    QString prefix;
#                    QString str = valueOffsetProf.toString().toUpper();
#                    QRegExp regPv("PV");
#                    QRegExp regPp("PP");
#
#                    double radProf;
#                    double radPk;

#                if ( str.contains(regPv) )
#                {
#                  str.replace(regPv, "" );
#                  prefix = "PV";
#
#                  radProf = ( azimuthOffsetProject + (180 - PvAzimuth)) * M_PI / 180;
#                  valueProfNew = prefix + QString::number( str.toDouble() + ( distanceOffsetProject * sin( radProf ) ) / PpInterval, 0, 0 ); //??? QVariant::fromValue
#
#                  radPk = ( (azimuthOffsetProject - PpAzimuth) ) * M_PI / 180;
#                  valuePkNew = QString::number( valueOffsetPk.toDouble() + ( distanceOffsetProject * sin( radPk ) ) / PvInterval, 0, 0);
#                }
#                else if ( str.contains(regPp) )
#                {
#                  str.replace(regPp, "" );
#                  prefix = "PP";
#
#                  double radProf = ( azimuthOffsetProject - PpAzimuth ) * M_PI / 180;
#                  valueProfNew =  prefix + QString::number( str.toDouble() + ( distanceOffsetProject * sin( radProf ) ) / PvInterval, 0, 0 ); //??? QVariant::fromValue
#
#                  double radPk = ( (PvAzimuth - azimuthOffsetProject) ) * M_PI / 180;
#                  valuePkNew = QString::number( valueOffsetPk.toDouble() + ( distanceOffsetProject * sin( radPk ) ) / PpInterval, 0, 0);
#                }
#                else
#                {
#                  //QMessageBox::information( 0, "1413", "ERROR_1413 not PV and not PP" );
#                  //return;
#                }
                
#        //          QMessageBox::information( 0, "1462_PV_or_PP",
#        //                                    "azimuthOffsetProject = " + QString::number(azimuthOffsetProject,2,2) + "\n"
#        //                                    "radProf = " + QString::number(radProf,2,2) + "\n"
#        //                                    "valueProfNew = " + valueProfNew.toString() + "\n"
#        //                                    "radPk = " + QString::number(radPk,2,2) + "\n"
#        //                                    "valuePkNew = " + valuePkNew.toString()
#        //                                    );

#                    mDataLayer.changeAttributeValue( mapDataFeatures[fData].id(), mDataLayer.fields().indexFromName(fieldDataProfNew.name()), valueProfNew, valueDataProfNew)
#                    mDataLayer.changeAttributeValue( mapDataFeatures[fData].id(), mDataLayer.fields().indexFromName(fieldDataPkNew.name()), valuePkNew, valueDataPkNew)

        mDataLayer.endEditCommand()
        mDataLayer.commitChanges()

        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        self.dockwidget.progress.setFormat("RUMB, OFFSET, AZIMUTH DONE")
          
        self.dockwidget.tabInfo.setTabEnabled(0,False)
        self.dockwidget.tabInfo.setTabEnabled(1,True)
        self.dockwidget.tabInfo.setTabEnabled(2,False)
        self.dockwidget.tabInfo.setCurrentIndex(1)
        self.dockwidget.toolMetod.setCurrentIndex(4)
        self.iface.statusBarIface().showMessage("DONE")
        
    #записать превышения из слоя(lExceed) в слой(lData) и нарисовать линейный слой(lTotalData)
    def ExceedInData(self, lData, lExceed, lTotalData):
        #print("ExceedInData()")
        #проверка слоев
        checkinglayerExceed = self.VectorLayerFromName(lExceed)
        checkinglayerTotalData = self.VectorLayerFromName(lTotalData)
        if  (lData == lExceed) or (lData == lTotalData) or (lExceed == lTotalData) or (checkinglayerTotalData.geometryType() != 1):
            self.iface.messageBar().pushMessage( "(lData == lExceed) or (lData == lTotalData) or (lExceed == lTotalData) or (checkinglayerExceed.geometryType() != 4) or (checkinglayer.geometryType() != 1)")
            print ("#return прервать функцию", "(lData == lExceed) or (lData == lTotalData) or (lExceed == lTotalData) or (checkinglayerExceed.geometryType() != 4) or (checkinglayer.geometryType() != 1)")                    
            return
            
        #вывод в statusBarIface()
        s = chr(60)
        self.iface.statusBarIface().showMessage(lData + " " + s + s + s + " " + lExceed)
        
        self.dockwidget.tInfoExceed.append( "Exceed: " + lExceed)
        self.dockwidget.tInfoExceed.append( "Total Data: " + lTotalData)
            
        #получаем Data, Offset и TotalData слои
        mDataLayer = self.VectorLayerFromName(lData)
        mExceedLayer = self.VectorLayerFromName(lExceed)
        mTotalDataLayer = self.VectorLayerFromName(lTotalData)

        #проверить наличие полей (PROF, PK, H, AUTHOR) в слоях
        listFields = ["PROF", "PK"]
        DataCheckingFields = self.CheckingFields(mDataLayer, listFields)
        listFields.append("H")
        listFields.append("AUTHOR")
        ExceedCheckingFields = self.CheckingFields(mExceedLayer, listFields)
        #print(listFields)
        
        if (DataCheckingFields == False) or (ExceedCheckingFields == False):
            print("#return прервать функцию", "(DataCheckingFields == False) or (ExceedCheckingFields == False)")
            return
        
        #write exceed (добавить поля H, AUTHOR)
        #удалить и создать поля (H, AUTHOR)
        listFields = ["H", "AUTHOR"]

        #удалить поля в Data, если они есть
        self.DeletingFields(mDataLayer, listFields)
        #создать поля в Data
        self.CreatingFields(mDataLayer, listFields)
        #создать поля в TotalData
        self.CreatingFields(mTotalDataLayer, ["PROF", "BEGIN", "END"])

        #получить список уникальных значений поля
        ListExceedProf = self.UniqueValues(mExceedLayer, mDataLayer.fields().field("PROF"))
        #print(ListExceedProf)
        
        fieldDataProf = mDataLayer.fields().field("PROF")
        fieldDataPk = mDataLayer.fields().field("PK")
        fieldDataH = mDataLayer.fields().field("H")
        fieldDataAuthor = mDataLayer.fields().field("AUTHOR")

        fieldExceedProf = mExceedLayer.fields().field("PROF")
        fieldExceedPk = mExceedLayer.fields().field("PK")
        fieldExceedH = mExceedLayer.fields().field("H")
        fieldExceedAuthor = mExceedLayer.fields().field("AUTHOR")
                        
        #начать редактирование слоя
        mDataLayer.startEditing()
        mDataLayer.beginEditCommand("begin")
        mTotalDataLayer.startEditing()
        mTotalDataLayer.beginEditCommand("begin")
        
        #прогресс заменить на системный прогресс
        p = 0
        self.dockwidget.progress.setRange(0, len(ListExceedProf))
        self.dockwidget.progress.setFormat("Exceed %p% ")
        for uExceed in ListExceedProf:
            #print(uExceed)
            p += 1 #percent = p / float(len(ListExceedProf)) * 100
            self.dockwidget.progress.setValue(p)
            self.dockwidget.progress.setFormat("Exceed %p% ")
            
            #вывод в statusBarIface()
            #self.iface.statusBarIface().showMessage("Exceed {} %".format(int(p)))
            #self.iface.statusBarIface().showMessage(lData + " " + chr(60) + " {} % ".format(int(p)) + chr(60) + " " + lExceed)
            
            if  (uExceed == ""):
                continue

            MapDataFeatures = self.MapFeatures(mDataLayer, mDataLayer.fields().field("PROF"), uExceed)
            MapExceedFeatures = self.MapFeatures(mExceedLayer, mExceedLayer.fields().field("PROF"), uExceed)
            
            if  ( len(MapExceedFeatures) < 2 ) or ( len(MapDataFeatures) < 2 ):
                continue
                
            if  ( len(MapExceedFeatures) >= 2 ) or ( len(MapDataFeatures) >= 2 ): 
                
                listDataFeatures = []
                e = 0
                while e < (len(MapExceedFeatures)-1):
                    #начальный пк
                    valueExceedProfini = MapExceedFeatures[e].attribute(fieldExceedProf.name())
                    valueExceedPkini = MapExceedFeatures[e].attribute(fieldExceedPk.name())
                    valueExceedHini = MapExceedFeatures[e].attribute(fieldExceedH.name())
                    valueExceedAuthorini = MapExceedFeatures[e].attribute(fieldExceedAuthor.name())
                    
                    #проверить начальный пк
                    if  ((valueExceedProfini != None) and (valueExceedPkini != None) and (valueExceedHini != None) and (valueExceedAuthorini != None)):
                        e += 1
                        #считать следующий пк
                        valueExceedProffin = MapExceedFeatures[e].attribute(fieldExceedProf.name())
                        valueExceedPkfin = MapExceedFeatures[e].attribute(fieldExceedPk.name())
                        valueExceedHfin = MapExceedFeatures[e].attribute(fieldExceedH.name())
                        valueExceedAuthorfin = MapExceedFeatures[e].attribute(fieldExceedAuthor.name())
                        e -= 1
                        
                        #следующий пк не пустой
                        if ((valueExceedProffin != None) and (valueExceedPkfin != None) and (valueExceedHfin != None) and (valueExceedAuthorfin != None)):

                            #print("Exceed", e, valueExceedProfini, valueExceedPkini, "-", valueExceedPkfin, valueExceedHini, valueExceedAuthorini)
                            
#                                    #Ошибка ввода в Exceed
#                                    if  (valueExceedPkini >= valueExceedPkfin):
#                                        print("ERROR", uExceed, valueExceedPkini, "-", valueExceedPkfin)
#                                        #инструкции
                                
                            #Ошибка ввода в Exceed и вывод пустых интервалов
                            if ((len(listDataFeatures))>0):
                                valueDataPk = listDataFeatures[-1].attribute(fieldDataPk.name())
                                
                                #Вывод пустых интервалов, разрывов и т.п.
                                if (valueDataPk != valueExceedPkini):
                                    self.dockwidget.tInfoExceed.append(uExceed + "\t" + str(valueDataPk) + "-" + str(valueExceedPkini) + "\t" + "(absence)")
                                    
                                if (valueExceedPkini < valueDataPk):
                                    self.dockwidget.tInfoExceed.append("ERROR:" + uExceed + str(valueDataPk) +  "-" + str(valueExceedPkini))
                                    #инструкции
                                
                            #ищем интервал в слое lData
                            interval = False
                            listDataFeatures = []
                            
                            d = 0
                            while d < (len(MapDataFeatures)-1):
                                valueDataProfini = MapDataFeatures[d].attribute(fieldDataProf.name())
                                valueDataPkini = MapDataFeatures[d].attribute(fieldDataPk.name())
                                valueDataHini = MapDataFeatures[d].attribute(fieldDataH.name())
                                valueDataAuthorini = MapDataFeatures[d].attribute(fieldDataAuthor.name())

                                #print("----------Data_ini", e, valueDataProfini, valueDataPkini, "-", "valueExceedPkfin", valueDataHini, valueDataAuthorini)                                        
                                
                                if ((valueDataProfini == valueExceedProfini ) and (valueDataPkini == valueExceedPkini)):

                                    listDataFeatures.append(MapDataFeatures[d])

                                    while d < (len(MapDataFeatures)-1):
                                        d += 1
                                        valueDataProffin = MapDataFeatures[d].attribute(fieldDataProf.name())
                                        valueDataPkfin = MapDataFeatures[d].attribute(fieldDataPk.name())
                                        valueDataHfin = MapDataFeatures[d].attribute(fieldDataH.name())
                                        valueDataAuthorfin = MapDataFeatures[d].attribute(fieldDataAuthor.name())
                                        
                                        listDataFeatures.append(MapDataFeatures[d])
                                        
                                        if ((valueDataProffin == valueExceedProffin ) and (valueDataPkfin == valueExceedPkfin)):
                                            #print("Data", e, valueDataProfini, valueDataPkini, "-", valueDataPkfin)
                                            interval = True
                                            break
                                d += 1
                                    
                            #Ошибка ввода в Exceed
                            if ((len(listDataFeatures) < 2) or (interval == False) or ((len(listDataFeatures) >= 2) and (interval == False))):
                                print("ERROR:", uExceed, valueExceedPkini, "-", valueExceedPkfin)
                                #сделать...инструкции
                                    
                            #интервал(минимум 2 пк) в lData найдены
                            if  ((len(listDataFeatures) >= 2) and (interval == True)):
                                listinifin = listDataFeatures
                                
                                #print("DataList (кол-во) and (interval == True)", len(listDataFeatures), "\n")
                                
                                #интерполяция превышения на интервал
                                valueH = (valueExceedHini / (valueExceedPkfin - valueExceedPkini))

                                #лист с точками линии
                                totalline = []
                                
                                fD = 0
                                while fD < (len(listDataFeatures)):
                                    feature = listDataFeatures[fD]
                                    valueDataPkini = feature.attribute(fieldDataPk.name())
                                    valueDataH = feature.attribute(fieldDataH.name())
                                    valueDataAuthor = feature.attribute(fieldDataAuthor.name())

                                    #добавить точки линии в лист
                                    valueDataX = feature.geometry().asPoint().y()
                                    valueDataY = feature.geometry().asPoint().x()
                                    totalpoint = QgsPointXY(valueDataY, valueDataX)
                                    totalline.append(totalpoint)
                                    
                                    if (fD < (len(listDataFeatures)-1)):
                                        valueDataPkfin = listDataFeatures[fD+1].attribute(fieldDataPk.name())

                                    valH = valueH * (valueDataPkfin - valueDataPkini)

                                    #заполнить поля H и AUTHOR в слое lData
                                    mDataLayer.changeAttributeValue( feature.id(), mDataLayer.fields().indexFromName(fieldDataH.name()), valH, valueDataH)
                                    mDataLayer.changeAttributeValue( feature.id(), mDataLayer.fields().indexFromName(fieldDataAuthor.name()), valueExceedAuthorini, valueDataAuthor)

                                    if  (fD == len(listDataFeatures)-1):
                                        mDataLayer.changeAttributeValue( feature.id(), mDataLayer.fields().indexFromName(fieldDataH.name()), valueExceedHfin, valueDataH)
                                        mDataLayer.changeAttributeValue( feature.id(), mDataLayer.fields().indexFromName(fieldDataAuthor.name()), valueExceedAuthorfin, valueDataAuthor)
                                    fD += 1
                                        
                                #добавить в слой TotalDataLayer линию totalline и заполнить поля PROF, BEGIN, END 
                                feat = QgsFeature(mTotalDataLayer.fields())
                                feat.setGeometry(QgsGeometry.fromPolylineXY(totalline))
                                feat.setAttributes([uExceed, valueExceedPkini, valueExceedPkfin])   #сколько полей - столько значений
                                mTotalDataLayer.addFeatures([feat])
                                totalline.clear()
                                d += 1

                        #следующий пк пустой
                        if  ((valueExceedProfini == None) or (valueExceedPkini == None) or (valueExceedHini == None) or (valueExceedAuthorini == None)):
                            while e < (len(MapExceedFeatures)-1):
                                e += 1
                                valueExceedProfini = MapExceedFeatures[e].attribute(fieldExceedProf.name())
                                valueExceedPkini = MapExceedFeatures[e].attribute(fieldExceedPk.name())
                                valueExceedHini = MapExceedFeatures[e].attribute(fieldExceedH.name())
                                valueExceedAuthorini = MapExceedFeatures[e].attribute(fieldExceedAuthor.name())
                                
                                #считать не пустой пк и сделать его начальным
                                if  ((valueExceedProfini != None) and (valueExceedPkini != None) and (valueExceedHini != None) and (valueExceedAuthorini != None)):
                                    e -= 1
                                    break
                                    
                    e += 1

        #прекратить редактирование слоя
        mDataLayer.endEditCommand()
        mDataLayer.commitChanges()
        mTotalDataLayer.endEditCommand()
        mTotalDataLayer.commitChanges()
        
        #длина линии
        #self.dockwidget.tInfoExceed.append( " ( " + str(totallength/1000, 10, 3) + " km )" )

    #записать выноса
    def OffsetInData(self, lData, lOffset):
        #print("OffsetInData()")
        
        #если слои одинаковые или не точечные, то вывести ошибку(прервать функцию)
        checkinglayer = self.VectorLayerFromName(lOffset)
        if  (lData == lOffset) or (checkinglayer.geometryType() != 0):
            self.iface.messageBar().pushMessage( "OffsetInData", "(lData == lOffset) or (checkinglayer.geometryType() != 0)")
            print("#return прервать функцию", "(lData == lOffset) or (checkinglayer.geometryType() != 0)")
            return
            
        #вывод в statusBarIface()
        s = chr(60)
        self.iface.statusBarIface().showMessage(lData + " " + s + s + s + " " + lOffset)
        
        self.dockwidget.tInfoOffset.append( "Offset: " + lOffset)
    
        #получаем Data и Offset слои
        mDataLayer = self.VectorLayerFromName(lData)
        mOffsetLayer = self.VectorLayerFromName(lOffset)
        
        #проверить наличие полей (PROF, PK, X, Y) в слоях
        listFields = ["PROF", "PK", "X", "Y"]
        DataCheckingFields = self.CheckingFields(mDataLayer, listFields)
        OffsetCheckingFields = self.CheckingFields(mOffsetLayer, listFields)
        
        if (DataCheckingFields == False) or (OffsetCheckingFields == False):
            print("#return прервать функцию", "(DataCheckingFields == False) or (OffsetCheckingFields == False)")
            return
        
        #write(rewrite) offsets (добавить поля V, OFFSET, AZIMUTH)
        #удалить и создать поля (V, OFFSET, AZIMUTH)
        if  (((self.dockwidget.toolMetod.currentIndex() == 1) and ((self.dockwidget.cbOffsetWrite.isChecked()) or (self.dockwidget.cbOffsetRewrite.isChecked())))  or 
            ((self.dockwidget.toolMetod.currentIndex() == 3) and ((self.dockwidget.cbOffsetWriteAll.isChecked()) or (self.dockwidget.cbOffsetRewriteAll.isChecked())))):
            #print("cbOffsetWrite, cbOffsetRewrite")
            listFields = ["V", "OFFSET", "AZIMUTH"]
            #DataCheckingFields = self.CheckingFields(mDataLayer, listFields)
            OffsetCheckingFields = self.CheckingFields(mOffsetLayer, listFields)
            if (OffsetCheckingFields == False):
                print("#return прервать функцию", "Нет полей (V, OFFSET, AZIMUTH) в выносном слое")
                return

            #удалить поля в Data, если включен cbOffsetRewrite или cbOffsetRewriteAll
            if  (((self.dockwidget.toolMetod.currentIndex() == 1) and (self.dockwidget.cbOffsetRewrite.isChecked())) or 
                ((self.dockwidget.toolMetod.currentIndex() == 3) and (self.dockwidget.cbOffsetRewriteAll.isChecked()))): 
                #print("cbOffsetRewrite")
                self.DeletingFields(mDataLayer, listFields)
            
            #создать поля в Data
            self.CreatingFields(mDataLayer, listFields)
        
        #начать редактирование слоя
        mDataLayer.startEditing()
        mDataLayer.beginEditCommand("begin")
        
        DictOffsetFeatures = self.DictLayerFeatures(mOffsetLayer)
        DictDataFeatures = self.DictLayerFeatures(mDataLayer)
        
        p = 0
        self.dockwidget.progress.setRange(0, len(DictOffsetFeatures))
        self.dockwidget.progress.setFormat("Offset %p%")
        for key,fOffset in DictOffsetFeatures.items():
            p += 1
            self.dockwidget.progress.setValue(p)
            #self.dockwidget.progress.update()
            
            #вывод в statusBarIface()
            #self.iface.statusBarIface().showMessage("Offset {} %".format(int(p)))
            #self.iface.statusBarIface().showMessage(lData + " " + chr(60) + " {} % ".format(int(p)) + chr(60) + " " + lOffset)
            
            valueOffsetProf = fOffset.attribute("PROF")
            valueOffsetPk = fOffset.attribute("PK")
            valueOffsetX = fOffset.attribute("X")
            valueOffsetY = fOffset.attribute("Y")
            geomOffset = fOffset.geometry()
            
            #print("len(MapDataFeatures) =", len(MapDataFeatures))
            
#            exp = "(" + "\"PROF\" = \'" + str(valueOffsetProf) + "\') AND (" + '\"PK\" = ' + str(valueOffsetPk) + ")"
#            #print(exp)
#            #break
#            request = QgsFeatureRequest()
#            request.setFilterExpression(exp)
            
#            print(mDataLayer.getFeatures(request))
#            for fData in mDataLayer.getFeatures(request):

            if  (key not in DictDataFeatures):
                continue
            
            fData = DictDataFeatures[key]
            valueDataProf = fData.attribute("PROF")
            valueDataPk = fData.attribute("PK")
            valueDataX = fData.attribute("X")
            valueDataY = fData.attribute("Y")
            
            #if  (valueOffsetProf == valueDataProf) and (valueOffsetPk == valueDataPk):
            self.dockwidget.tInfoOffset.append(valueDataProf + "\t" + str(valueDataPk) + "\t" + str(round(valueOffsetX, 3)) + "\t" + str(round(valueOffsetY, 3)) + "\t(offset)")

            #сместить точку по новым координатам
            mDataLayer.changeGeometry(fData.id(), geomOffset)

            #записать значения полей X и Y
            mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName("X"), valueOffsetX, valueDataX)
            mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName("Y"), valueOffsetY, valueDataY)
            
            #заполнить поля (V, OFFSET, AZIMUTH), если включен (cbOffsetWrite, cbOffsetWriteAll) или (cbOffsetRewrite, cbOffsetrewriteAll)
            if  (((self.dockwidget.toolMetod.currentIndex() == 1) and ((self.dockwidget.cbOffsetWrite.isChecked()) or (self.dockwidget.cbOffsetRewrite.isChecked())))  or 
                ((self.dockwidget.toolMetod.currentIndex() == 3) and ((self.dockwidget.cbOffsetWriteAll.isChecked()) or (self.dockwidget.cbOffsetRewriteAll.isChecked())))):
                valueOffsetV = fOffset.attribute("V")
                valueOffsetOffset = fOffset.attribute("OFFSET")
                valueOffsetAzimuth = fOffset.attribute("AZIMUTH")
                valueDataV = fData.attribute("V")
                valueDataOffset = fData.attribute("OFFSET")
                valueDataAzimuth = fData.attribute("AZIMUTH")
                #valueDataDate = fData.attribute("DATE")
                mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName("V"), valueOffsetV, valueDataV)
                mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName("OFFSET"), valueOffsetOffset, valueDataOffset)
                mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName("AZIMUTH"), valueOffsetAzimuth, valueDataAzimuth)
                #mDataLayer.changeAttributeValue(fData.id(), mDataLayer.fields().indexFromName("DATE"), valueOffsetDate, valueDataDate)
    
        #прекратить редактирование слоя
        mDataLayer.endEditCommand()
        mDataLayer.commitChanges()
    
    def BasisInData(self, lData, lBasis, lJustusData, vDistance):
        #print("BasisInData()")
        #получаем Data и Basis слои
        mDataLayer = self.VectorLayerFromName(lData)
        mBasisLayer = self.VectorLayerFromName(lBasis)
        mJustusDataLayer = self.VectorLayerFromName(lJustusData)

        #вывод в statusBarIface()
        s = chr(60)
        self.iface.statusBarIface().showMessage(lData + " " + s + s + s + " " + lBasis)
        
        self.dockwidget.tInfoBasis.append( "Basis: " + lBasis)
        self.dockwidget.tInfoBasis.append( "JustusData: " + lJustusData)
        
        #проверить наличие поля HZ в слоях
        BasisCheckingFields = self.CheckingFields(mBasisLayer, ["HZ"])
        
        if (BasisCheckingFields == False):
            print("#return прервать функцию", "(BasisCheckingFields == False)")
            return
        
        #write basis (добавить поле HZ)
        #удалить и создать поля (H, AUTHOR)
        #удалить поля в Data, если они есть
        self.DeletingFields(mDataLayer, ["HZ"])
        #создать поля в Data
        self.CreatingFields(mDataLayer, ["HZ"])
        #создать поля в TotalData
        self.CreatingFields(mJustusDataLayer, ["PROF", "BEGIN", "END"])

        #запись опорных точек из Basis(значение поля HZ) в Data(значение поля HZ)
        fieldBasisHz = mBasisLayer.fields().field("HZ")
        fieldDataHz = mDataLayer.fields().field("HZ")

        mDataLayer.startEditing()
        mDataLayer.beginEditCommand("begin")

        p = 0
        self.dockwidget.progress.setRange(0, mBasisLayer.featureCount())
        self.dockwidget.progress.setFormat("Basis %p%")
        for fBasis in mBasisLayer.getFeatures():
            p += 1
            self.dockwidget.progress.setValue(p)
            #self.dockwidget.progress.update()
            
            #вывод в statusBarIface()
            #self.iface.statusBarIface().showMessage("Basis {} %".format(int(p)))
            #self.iface.statusBarIface().showMessage(lData + " " + chr(60) + " {} % ".format(int(p)) + chr(60) + " " + lBasis)
            
            valueBasisHz = fBasis.attribute(fieldBasisHz.name())
            point = fBasis.geometry().asPoint()
            
            #//create the search rectangle
            r = QgsRectangle()
            r.setXMinimum( point.x() - vDistance )
            r.setXMaximum( point.x() + vDistance )
            r.setYMinimum( point.y() - vDistance )
            r.setYMaximum( point.y() + vDistance )
            
            bbox = self.iface.mapCanvas().mapSettings().mapToLayerCoordinates( mDataLayer, r )
            boxData = mDataLayer.getFeatures(bbox)
            #fitData = mDataLayer.getFeatures(QgsFeatureRequest().setFilterRect(bbox).setFlags( QgsFeatureRequest.ExactIntersect ))                    
            
            for fData in boxData:
                valueDataHz = fData.attribute(fieldDataHz.name())
                mDataLayer.changeAttributeValue( fData.id(), mDataLayer.fields().indexFromName(fieldDataHz.name()), valueBasisHz, valueDataHz)

        mDataLayer.endEditCommand()
        mDataLayer.commitChanges()
    
    def DataZfhzfz(self, lData, lJustusData, vFail):
        #print("DataZ()")
        #получаем Data и JustusData слои
        mDataLayer = self.VectorLayerFromName(lData)
        mJustusDataLayer = self.VectorLayerFromName(lJustusData)
        
        #вывод в statusBarIface()
        s = chr(60)
        self.iface.statusBarIface().showMessage(lData + " " + s + s + s + " Z, FH, ZF, ZFZ")
        
        #проверить наличие полz HZ в слоях
        DataCheckingFields = self.CheckingFields(mDataLayer, ["PROF", "PK", "H", "AUTHOR","HZ"])
        
        if (DataCheckingFields == False):
            print("#return прервать функцию", "(DataCheckingFields == False)")
            return
        
        #write basis (добавить поле HZ)
        #удалить и создать поля ["Z", "FH", "ZF"]
        self.DeletingFields(mDataLayer, ["Z", "FH", "ZF", "ZFZ"])
        self.CreatingFields(mDataLayer, ["Z", "FH", "ZF", "ZFZ"])

        #получить список уникальных значений поля
        ListDataProf = self.UniqueValues(mDataLayer, mDataLayer.fields().field("PROF"))

        #///*< рассчитать Z, FH, ZF  >*///
        fieldDataProf = mDataLayer.fields().field("PROF")
        fieldDataPk = mDataLayer.fields().field("PK")
        fieldDataX = mDataLayer.fields().field("X")
        fieldDataY = mDataLayer.fields().field("Y")
        fieldDataH = mDataLayer.fields().field("H")
        fieldDataAuthor = mDataLayer.fields().field("AUTHOR")
        fieldDataHz = mDataLayer.fields().field("HZ")
        fieldDataZ = mDataLayer.fields().field("Z")
        fieldDataFh = mDataLayer.fields().field("FH")
        fieldDataZf = mDataLayer.fields().field("ZF")
        fieldDataZfz = mDataLayer.fields().field("ZFZ")
        
        #начать редактирование слоя
        mDataLayer.startEditing()
        mDataLayer.beginEditCommand("begin")
        mJustusDataLayer.startEditing()
        mJustusDataLayer.beginEditCommand("begin")
        
        p = 0
        self.dockwidget.progress.setRange(0, len(ListDataProf))
        self.dockwidget.progress.setFormat("Z, FH, ZF, ZFZ %p%")
        for uData in ListDataProf:
            p += 1
            self.dockwidget.progress.setValue(p)
            #self.dockwidget.progress.update()
            
            if  (uData == ""):
                continue
            
            MapDataFeatures = self.MapFeatures(mDataLayer, mDataLayer.fields().field("PROF"), uData)

            if  (len(MapDataFeatures) < 2):
                continue

            if  (len(MapDataFeatures) >= 2 ):
                d = 0
                while d < (len(MapDataFeatures)):
                    valueDataPk = MapDataFeatures[d].attribute(fieldDataPk.name())
                    valueDataH = MapDataFeatures[d].attribute(fieldDataH.name())
                    valueDataAuthor = MapDataFeatures[d].attribute(fieldDataAuthor.name())
                    valueDataHz = MapDataFeatures[d].attribute(fieldDataHz.name())                            
                    
                    #разделение интервалов по HZ(опоре, вис)
                    hzbool = False
                    if  (valueDataH != None) and (valueDataAuthor != None):
                        hzFeatures = [] #hzFeatures[] - опорный или висячий интервал
                        lAuthors = []
                        sumH = 0 #сумма превышений
                        
                        while d < (len(MapDataFeatures)):
                            #valueDataPk = MapDataFeatures[d].attribute(fieldDataPk.name())
                            valueDataH = MapDataFeatures[d].attribute(fieldDataH.name())
                            valueDataAuthor = MapDataFeatures[d].attribute(fieldDataAuthor.name())
                            
                            if  (valueDataH == None) or (valueDataAuthor == None):
                                d += 1
                                break
                                
                            if  (valueDataH != None) and (valueDataAuthor != None):
                                sumH += valueDataH
                                hzFeatures.append(MapDataFeatures[d])
                                
                                if  valueDataAuthor not in lAuthors:
                                    lAuthors.append(valueDataAuthor)
                                    
                            d += 1
                            if d < (len(MapDataFeatures)):
                                #valueDataPk = MapDataFeatures[d].attribute(fieldDataPk.name())
                                valueDataH = MapDataFeatures[d].attribute(fieldDataH.name())
                                valueDataAuthor = MapDataFeatures[d].attribute(fieldDataAuthor.name())
                                valueDataHz = MapDataFeatures[d].attribute(fieldDataHz.name())
                                if  (valueDataHz != None) and (valueDataH != None) and (valueDataAuthor != None):
                                    hzbool = True
                                    hzFeatures.append(MapDataFeatures[d])
                                    #print(hzFeatures[0].attribute(fieldDataPk.name()), "-",  hzFeatures[-1].attribute(fieldDataPk.name()))
                                    #d -= 1
                                    break
                        
                        valuePkini = hzFeatures[0].attribute(fieldDataPk.name()) #начальный пикет
                        valuePkfin = hzFeatures[-1].attribute(fieldDataPk.name()) #последний пикет
                        
                        if  (len(hzFeatures) < 2) or (valuePkini == valuePkfin):
                            d += 1
                            continue
                            
                        #print("len(hzFeatures) =", len(hzFeatures), ":", valuePkini, "-", valuePkfin)
                        
                        if (len(hzFeatures) >=2):
                            
                            authors = ""
                            for ar in lAuthors:
                                if (ar == lAuthors[-1]):
                                    authors += ar
                                    break
                                authors += ar + "_"
                            
                            #опорный интервал
                            if (hzFeatures[0].attribute(fieldDataHz.name()) != None) and (hzFeatures[-1].attribute(fieldDataHz.name()) != None):
                                #заполнить поле Z, FH, ZF
                                valueZ = hzFeatures[0].attribute(fieldDataHz.name())
                                valueFh = hzFeatures[-1].attribute(fieldDataHz.name()) - sumH - valueZ
                                fh = valueFh / (hzFeatures[-1].attribute(fieldDataPk.name()) - hzFeatures[0].attribute(fieldDataPk.name()))
                                valueZf = hzFeatures[0].attribute(fieldDataHz.name())
                                
                                #лист с точками линии
                                justusline = []
                                
                                #модуль valueFh
                                if  (valueFh >= 0):
                                    vFh = valueFh
                                else: vFh = -valueFh
                                
                                failbegin = "["
                                failend = "]"
                                
                                if ( vFh > vFail ):
                                    failbegin = "<["
                                    failend = "]>"
        
                                hz = 0
                                while hz < (len(hzFeatures)):
                                    valueDataH = hzFeatures[hz].attribute(fieldDataH.name())
                                    valueDataAuthor = hzFeatures[hz].attribute(fieldDataAuthor.name())
                                    valueDataHz = hzFeatures[hz].attribute(fieldDataHz.name())
                                    valueDataZ = hzFeatures[hz].attribute(fieldDataZ.name())
                                    valueDataFh = hzFeatures[hz].attribute(fieldDataFh.name())
                                    valueDataZf = hzFeatures[hz].attribute(fieldDataZf.name())
                                    valueDataZfz = hzFeatures[hz].attribute(fieldDataZfz.name())
                                    
                                    if (vFh <= vFail):
                                        #добавить точки линии в лист
                                        valueDataX = hzFeatures[hz].geometry().asPoint().y()
                                        valueDataY = hzFeatures[hz].geometry().asPoint().x()
                                        justuspoint = QgsPointXY(valueDataY, valueDataX)
                                        justusline.append(justuspoint)
          
                                    mDataLayer.changeAttributeValue(hzFeatures[hz].id(), mDataLayer.fields().indexFromName(fieldDataZ.name()), valueZ, valueDataZ)
                                    if (hzFeatures[hz] == hzFeatures[-1]):
                                        mDataLayer.changeAttributeValue( hzFeatures[hz].id(), mDataLayer.fields().indexFromName(fieldDataZ.name()), valueDataHz, valueDataZ)
                                    
                                    mDataLayer.changeAttributeValue(hzFeatures[hz].id(), mDataLayer.fields().indexFromName(fieldDataFh.name()), valueFh, valueDataFh)
                                    if (hzFeatures[hz] == hzFeatures[-1]):
                                        mDataLayer.changeAttributeValue(hzFeatures[hz].id(), mDataLayer.fields().indexFromName(fieldDataFh.name()), 0, valueDataFh)
                                        
                                    mDataLayer.changeAttributeValue(hzFeatures[hz].id(), mDataLayer.fields().indexFromName(fieldDataZf.name()), valueZf, valueDataZf)
                                        
                                    valueZ += float(valueDataH)
                                    valueZf += float(valueDataH)
                                    valueZf += fh  
                                    
                                    hz += 1
                                
                                if  (len(justusline) >= 2):
                                    #добавить в слой JustusDataLayer линию justusline и заполнить поля PROF, BEGIN, END 
                                    feat = QgsFeature(mJustusDataLayer.fields())
                                    feat.setGeometry(QgsGeometry.fromPolylineXY(justusline))
                                    feat.setAttributes([uData, valuePkini, valuePkfin]) #сколько полей - столько значений
                                    mJustusDataLayer.addFeatures([feat])
                                    
                                if  (valuePkini != valuePkfin):
                                    self.dockwidget.tInfoBasis.append( uData + "\t" + str(valuePkini) + "-" + str(valuePkfin) + "\t" + str(round(valueFh,2)) + "\t" + failbegin + "\t" + authors + "\t" + failend)
                                    
                                justusline.clear()
                                d -= 1
                            
                            #вис на уменьшение
                            if (hzFeatures[0].attribute(fieldDataHz.name()) == None) and (hzFeatures[-1].attribute(fieldDataHz.name()) != None):
                                #print("visini\n")
                                valueZ = (hzFeatures[-1].attribute(fieldDataHz.name())) - sumH
                                
                                failbegin = "<"
                                failend =  "|"
                                
                                ini = 0
                                while ini < (len(hzFeatures)):
                                    valueDataH = hzFeatures[ini].attribute(fieldDataH.name())
                                    valueDataAutor = hzFeatures[ini].attribute(fieldDataAuthor.name())
                                    valueDataZ = hzFeatures[ini].attribute(fieldDataZ.name())
                                    
                                    if  valueDataAuthor not in lAuthors:
                                        lAuthors.append(valueDataAutor)
                                        
                                    mDataLayer.changeAttributeValue( hzFeatures[ini].id(), mDataLayer.fields().indexFromName(fieldDataZ.name()), valueZ, valueDataZ)
                                    valueZ += valueDataH
                                    ini += 1
                               
                                if  (valuePkini != valuePkfin):
                                    self.dockwidget.tInfoBasis.append( uData + "\t" + str(valuePkini) + "-" + str(valuePkfin) + "\t" + "pendend" + "\t" + failbegin + "\t" + authors + "\t" + failend)
                                    
                                d -= 1
                            
                            #вис на увеличение
                            if (hzFeatures[0].attribute(fieldDataHz.name()) != None) and (hzFeatures[-1].attribute(fieldDataHz.name()) == None):
                                #print("visfin\n")
                                valueZ = (hzFeatures[0].attribute(fieldDataHz.name()))
                                
                                failbegin = "|"
                                failend =  ">"
                                
                                fin = 0
                                while fin < (len(hzFeatures)):
                                    valueDataH = hzFeatures[fin].attribute(fieldDataH.name())
                                    valueDataAutor = hzFeatures[fin].attribute(fieldDataAuthor.name())
                                    valueDataZ = hzFeatures[fin].attribute(fieldDataZ.name())
                                    
                                    mDataLayer.changeAttributeValue( hzFeatures[fin].id(), mDataLayer.fields().indexFromName(fieldDataZ.name()), valueZ, valueDataZ)
                                    valueZ += valueDataH
                                    fin += 1
                               
                                if  (valuePkini != valuePkfin):
                                    self.dockwidget.tInfoBasis.append( uData + "\t" + str(valuePkini) + "-" + str(valuePkfin) + "\t" + "pendend" + "\t" + failbegin + "\t" + authors + "\t" + failend)
                                    
                                d -= 1
                        #нет опорных точек
                        if  (hzbool == False):
                            self.dockwidget.tInfoBasis.append( uData + "\t" + str(valuePkini) + "-" + str(valuePkfin) + "\t(no_basis)" )
                            
                    d += 1
                    
        #заполнить поле ZFZ
        for f in mDataLayer.getFeatures():
            valueDataHz = f.attribute(fieldDataHz.name())
            valueDataZ = f.attribute(fieldDataZ.name())
            valueDataZf = f.attribute(fieldDataZf.name())
            valueDataZfz = f.attribute(fieldDataZfz.name())
            
            if  (valueDataHz != None):
                mDataLayer.changeAttributeValue(f.id(), mDataLayer.fields().indexFromName(fieldDataZfz.name()), valueDataHz, valueDataZfz)
            elif    (valueDataZf != None):
                mDataLayer.changeAttributeValue(f.id(), mDataLayer.fields().indexFromName(fieldDataZfz.name()), valueDataZf, valueDataZfz)
            elif    (valueDataZ != None):
                mDataLayer.changeAttributeValue(f.id(), mDataLayer.fields().indexFromName(fieldDataZfz.name()), valueDataZ, valueDataZfz)
#                    else:
#                        mDataLayer.changeAttributeValue(hzFeatures[hz].id(), mDataLayer.fields().indexFromName(fieldDataZfz.name()), "", valueDataZfz)
                    
        mDataLayer.endEditCommand()
        mDataLayer.commitChanges()
        mJustusDataLayer.endEditCommand()
        mJustusDataLayer.commitChanges()
    
#    def AllInData(self, lData, lExceed, lOffset, lBasis, lTotalData, lJustusData, vFail, vDistance):
#        print("AllInData")
    
    def applyClicked(self):
        #print("***applyClicked***")
            
        self.dockwidget.tInfoExceed.clear()
        self.dockwidget.tInfoOffset.clear()
        self.dockwidget.tInfoBasis.clear()
        
        self.dockwidget.tInfoExceed.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        self.dockwidget.tInfoOffset.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        self.dockwidget.tInfoBasis.append(QTime.currentTime().toString(Qt.DefaultLocaleLongDate)) #время
        
        selLayers = self.iface.layerTreeView().selectedLayers()
        if  ( len(selLayers) < 1 ):
            self.iface.messageBar().pushMessage( "Select Data layer(s)!", "(ERROR: )")
            print("#return прервать функцию", "len(selLayers) < 1")
            return

        #проверка Data слоя(ёв)
        for nData in selLayers:
            #checkinglayer = nData
            if  (nData.geometryType() != 0): #or (!checkinglayer) вставить, доделать
                self.iface.messageBar().pushMessage( "Data layer! (ERROR: Data)", "(ERROR: )" )
                print("#return прервать функцию", "checkinglayer.geometryType() != 0")
                return
        
        #основной цикл
        for nameData in selLayers:
            if  self.dockwidget.toolMetod.currentIndex() == 0: 
                #print("***Exceeed***")

                self.dockwidget.tabInfo.setTabEnabled(0, True)
                self.dockwidget.tabInfo.setTabEnabled(1, False)
                self.dockwidget.tabInfo.setTabEnabled(2, False)
                self.dockwidget.tabInfo.setCurrentIndex(0)
                
                self.dockwidget.tInfoExceed.append("Data: " + nameData.name())
                self.ExceedInData(nameData.name(), self.dockwidget.lvExceed.currentIndex().data(), self.dockwidget.cbTotalData.currentText())
                self.dockwidget.progress.setFormat("Exceed DONE")
                
            if  self.dockwidget.toolMetod.currentIndex() == 1:
                #print("***Offset***")

                self.dockwidget.tabInfo.setTabEnabled(0, False)
                self.dockwidget.tabInfo.setTabEnabled(1, True)
                self.dockwidget.tabInfo.setTabEnabled(2, False)
                self.dockwidget.tabInfo.setCurrentIndex(1)

                self.dockwidget.tInfoOffset.append("Data: " + nameData.name())
                self.OffsetInData(nameData.name(), self.dockwidget.lvOffset.currentIndex().data())
                self.dockwidget.progress.setFormat("Offset DONE")
                
            if  self.dockwidget.toolMetod.currentIndex() == 2:
                #print("***Basis***")
                
                self.dockwidget.tabInfo.setTabEnabled(0, False)
                self.dockwidget.tabInfo.setTabEnabled(1, False)
                self.dockwidget.tabInfo.setTabEnabled(2, True)
                self.dockwidget.tabInfo.setCurrentIndex(2)
                
                self.dockwidget.tInfoBasis.append("Data: " + nameData.name())
                self.BasisInData(nameData.name(), self.dockwidget.lvBasis.currentIndex().data(), self.dockwidget.cbJustusData.currentText() , self.dockwidget.dsbTolerance.value())
                self.DataZfhzfz(nameData.name(), self.dockwidget.cbJustusData.currentText(), self.dockwidget.dsbFail.value())
                self.dockwidget.progress.setFormat("Basis DONE")
                
            if  self.dockwidget.toolMetod.currentIndex() == 3:
                #print("***All***")
                
                self.dockwidget.tabInfo.setTabEnabled(0, True)
                self.dockwidget.tabInfo.setTabEnabled(1, True)
                self.dockwidget.tabInfo.setTabEnabled(2, True)
                self.dockwidget.tabInfo.setCurrentIndex(0)
                
                self.dockwidget.tInfoExceed.append("Data: " + nameData.name())
                self.dockwidget.tInfoOffset.append("Data: " + nameData.name())
                self.dockwidget.tInfoBasis.append("Data: " + nameData.name())
                
                self.OffsetInData(nameData.name(), self.dockwidget.cbOffsetAll.currentText())
                self.ExceedInData( nameData.name(), self.dockwidget.cbExceedAll.currentText(), self.dockwidget.cbTotalDataAll.currentText())
                self.BasisInData(nameData.name(), self.dockwidget.cbBasisAll.currentText(), self.dockwidget.cbJustusDataAll.currentText(), self.dockwidget.dsbToleranceAll.value())
                self.DataZfhzfz(nameData.name(), self.dockwidget.cbJustusDataAll.currentText(), self.dockwidget.dsbFailAll.value())
                self.dockwidget.progress.setFormat("ALL DONE")
                              
        self.dockwidget.tInfoExceed.append( QTime.currentTime().toString(Qt.DefaultLocaleLongDate) + "\n") #время
        self.dockwidget.tInfoOffset.append( QTime.currentTime().toString(Qt.DefaultLocaleLongDate) + "\n") #время
        self.dockwidget.tInfoBasis.append( QTime.currentTime().toString(Qt.DefaultLocaleLongDate) + "\n") #время
        
        #вывод RESULT
        self.dockwidget.toolMetod.setCurrentIndex(4)
        
        self.iface.statusBarIface().showMessage("DONE")
        
    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
           
        icon_path = ':/plugins/alignment_plugin/icon.png'
        self.add_action(
            icon_path,
            text = self.tr(u'Alignment'),
            callback = self.run,
            parent = self.iface.mainWindow())
        
        loadLyr = self.LoaderLayers()

        self.dockwidget.pbApply.clicked.connect(self.applyClicked)
        self.dockwidget.pbTotalDataClear.clicked.connect(self.ClearLayer)
        self.dockwidget.pbJustusDataClear.clicked.connect(self.ClearLayer)
        self.dockwidget.pbTotalDataAllClear.clicked.connect(self.ClearLayer)
        self.dockwidget.pbJustusDataAllClear.clicked.connect(self.ClearLayer)
        
        self.dockwidget.tabInfo.setTabEnabled(0,False)
        self.dockwidget.tabInfo.setTabEnabled(1,False)
        self.dockwidget.tabInfo.setTabEnabled(2,False)

#        QgsSettings guisettings;
#        guisettings.beginGroup( QStringLiteral( "/Plugins" ) );
#        const QStringList groupKeys = guisettings.allKeys();
#        QStringList::const_iterator groupKeyIt = groupKeys.constBegin();
#        for ( ; groupKeyIt != groupKeys.constEnd(); ++groupKeyIt )
#          {
#            if ( groupKeyIt->contains( QLatin1String( "dsbFailValue" ) ) )
#            {
#                dsbFail->setValue( guisettings.value("dsbFailValue").toDouble() );
#                dsbFailAll->setValue( guisettings.value("dsbFailValue").toDouble() );
#            }
#            if ( groupKeyIt->contains( QLatin1String( "dsbToleranceValue" ) ) )
#            {
#                dsbTolerance->setValue( guisettings.value("dsbToleranceValue").toDouble() );
#                dsbToleranceAll->setValue( guisettings.value("dsbToleranceValue").toDouble() );
#            }
#          }
#          guisettings.endGroup();

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print("** CLOSING AlignmentPlugin")

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False
        
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print("** UNLOAD AlignmentPlugin")

        for action in self.actions:
            self.iface.removePluginMenu(self.tr(u'&Alignment'), action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    
    def run(self):
        """Run method that loads and starts the plugin"""   
        if  not self.pluginIsActive:
            self.pluginIsActive = True
            
            #print("** STARTING AlignmentPlugin")
            
            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if  self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = AlignmentPluginDockWidget()
         
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            loadLyr = self.LoaderLayers()

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
        
        elif  self.pluginIsActive:
            self.onClosePlugin()
            loadLyr = self.LoaderLayers()
            self.dockwidget.hide()
#            self.pluginIsActive = False
#            self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)
            

        #self.dockwidget.lvOffset.selectionModel().selectionChanged.connect(ContextMenu) #переделать на правую кнопку мыши